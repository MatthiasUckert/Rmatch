---
title: "flat_full.Rmd for working package"
output: html_document
editor_options: 
  chunk_output_type: console
---

<!-- Run this 'development' chunk -->

<!-- Store every call to library() that you need to explore your functions -->

```{r development, include=FALSE}
library(testthat); library(tidyverse); library(stringi); library(fst)
```

```{=html}
<!--
 You need to run the 'description' chunk in the '0-dev_history.Rmd' file before continuing your code there.

If it is the first time you use {fusen}, after 'description', you can directly run the last chunk of the present file with inflate() inside.
-->
```
```{r development-2}
pkgload::load_all(path = here::here(), export_all = FALSE)
```

# Functions

## HELP: standardize_str
```{r dev-standardize_str}
.str <- "International Business Corporation"
.op = c("space", "punct", "case", "utf8")
```

### Function

```{r function-standardize_str}
#' Title
#' 
#' Description
#' 
#' @param .str A string
#' @param .op Operations to perform
#'
#' @return A string
#' 
#' @export
standardize_str <- function(.str, .op = c("space", "punct", "case", "utf8")) {
  str_ <- .str
  
  if ("punct" %in% .op) {
    str_ <- trimws(stringi::stri_replace_all_regex(str_, "\\W", " "))
    str_ <- trimws(stringi::stri_replace_all_regex(str_, "[[:punct:]]", " "))
    
    if (!"space" %in% .op) {
      str_ <- trimws(stringi::stri_replace_all_regex(str_, "([[:blank:]]|[[:space:]])+", " "))
    }
  }
  
  if ("space" %in% .op) {
    str_ <- trimws(stringi::stri_replace_all_regex(str_, "([[:blank:]]|[[:space:]])+", " "))
  }
  
  if ("case" %in% .op) {
    str_ <- toupper(str_)
  }
  
  if ("utf8" %in% .op) {
    str_ <- stringi::stri_enc_toutf8(str_)
  }
  
  return(str_)
  
}
```

### Example/Test
```{r example-standardize_str, eval=FALSE}
standardize_str(c("jkldsa   jkdhas   äää  §$ ## #'''"))
```

```{r tests-standardize_str}
test_that("standardize_str works", {
  expect_true(inherits(standardize_str, "function")) 
})
```

## MAIN: standardize_data
```{r dev-standardize_data}
.data <- table_source
.cols <- c("name", "iso3", "city", "address")
.op = c("space", "punct", "case", "utf8")
```

### Function
```{r function-standardize_data}
#' Title
#' 
#' Description
#' 
#' @param .data A dataframe
#' @param .cols Columns to standardize
#' @param .fun Function for standardization, if NULL standardize_str() is used
#'
#' @return A dataframe
#' 
#' @export
standardize_data <- function(.data, .cols, .fun = NULL) {
  tab_ <- .data
  if (is.null(.fun)) {
    f_ <- standardize_str
  } else {
    f_ <- .fun
  }
  
  for (i in .cols) {
    tab_[[i]] <- f_(tab_[[i]])
  }
  return(tab_)
}
```

### Example/Test
```{r example-standardize_data, eval=FALSE}
standardize_data(table_source, c("name", "iso3", "city", "address"))
```

```{r tests-standardize_data}
test_that("standardize_data works", {
  expect_true(inherits(standardize_data, "function")) 
})
```

## MAIN: extract_legal_form
```{r dev-extract_legal_form}
.data <- table_source
.col <- "name"
.legal_forms <- tibble(.rows = 0)
.workers = future::availableCores()
```

### Function
```{r function-extract_legal_form}
#' Title
#' 
#' Description
#' 
#' @param .data A dataframe
#' @param .col The column with firm names
#' @param .legal_forms A dataframe with legal forms
#' @param .workers NUmber of workers for parallelisation
#'
#' @return A dataframe
#' 
#' @importFrom rlang :=
#' 
#' @export
extract_legal_form <- function(.data, .col, .legal_forms = data.frame(), .workers = future::availableCores()) {
  tmp <- legal_form_orig <- legal_form_stand <- legal_form <- name <- NULL
  
  if (nrow(.legal_forms) == 0) {
    tab_lf_ <- get("legal_form_all")
  } else {
    tab_lf_ <- .legal_forms
  }

  tab_ <- standardize_data(.data, .col)
  lf_ <- unique(tab_lf_[["legal_form_orig"]])
  nm_ <- tab_[[.col]]

  f_ <- carrier::crate(function(.lf, .nm) which(endsWith(.nm, paste0(" ", .lf))))
  future::plan("multisession", workers = 6)
  lf_ext_ <- furrr::future_map(
    .x = purrr::set_names(lf_, lf_),
    .f = ~ f_(.x, nm_),
    .options = furrr::furrr_options(seed = TRUE)
  )
  future::plan("default")
  lf_ext_ <- lf_ext_ %>%
    purrr::compact() %>%
    tibble::enframe(name = "legal_form_orig", value = "tmp") %>%
    tidyr::unnest(tmp) %>%
    dplyr::arrange(dplyr::desc(nchar(legal_form_orig))) %>%
    dplyr::distinct(tmp, .keep_all = TRUE)

  tab_ %>%
    dplyr::mutate(tmp = dplyr::row_number()) %>%
    dplyr::left_join(lf_ext_, by = "tmp") %>%
    dplyr::left_join(tab_lf_, by = c("iso3", "legal_form_orig")) %>%
    dplyr::rename(legal_form = legal_form_stand) %>%
    dplyr::relocate(legal_form, .after = !!dplyr::sym(.col)) %>%
    dplyr::mutate(
      !!dplyr::sym(paste0(.col, "_adj")) := trimws(
        stringi::stri_replace_last_fixed(name, legal_form_orig, "")
        ),
      .after = !!dplyr::sym(.col)
    ) %>%
    dplyr::select(-legal_form_orig, -tmp)
  
  
}
```

### Example/Test
```{r example-extract_legal_form, eval=FALSE}
extract_legal_form(table_source[1:100, ], "name", .workers = 1)
```

```{r tests-extract_legal_form}
test_that("extract_legal_form works", {
  expect_true(inherits(extract_legal_form, "function")) 
})
```

## HELP: match_col
```{r dev-match_col}
.source <- table_source[1:100, ]
.target <- table_target[1:1000, ]
.col <- "name"
.method = "osa"
.max_match = 10
.min_sim = 0
```

### Function

```{r function-match_col}
#' Match a on a single column
#' 
#' Description
#' 
#' @param .source 
#' The Source Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .target 
#' The Traget Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .col 
#' The column name to match as a string
#' @param .max_match 
#' Maximum number of matches to return (Default = 10)
#' @param .min_sim 
#' Minimum Similarity as defined by the chosen method
#' @param .method 
#' One of "osa", "lv", "dl", "hamming", "lcs", "qgram", "cosine", "jaccard", "jw", "soundex"
#' See stringdist package
#'
#' @return A Dataframe
match_col <- function(.source, .target, .col, .max_match = 10, .min_sim = .8, .method = "osa") {
  V1 <- value <- id <- name <- id_t <- sim <- NULL
  
  
  method_ <- match.arg(
    arg = .method,
    choices = c(
      "osa", "lv", "dl", "hamming", "lcs", "qgram", "cosine",
      "jaccard", "jw", "soundex"
    )
  )
  tab_ <- stringdist::stringsimmatrix(
    a = .source[[.col]],
    b = .target[[.col]],
    method = method_
  ) %>%
    tibble::as_tibble() %>%
    dplyr::mutate(id = dplyr::row_number(), .before = V1) %>%
    tidyr::pivot_longer(!dplyr::matches("id")) %>%
    dplyr::filter(value >= .min_sim) %>%
    dplyr::group_by(id) %>%
    dplyr::slice_max(order_by = value, n = .max_match) %>%
    dplyr::ungroup() %>%
    dplyr::rename(id_s = id, id_t = name) %>%
    dplyr::mutate(id_t = as.integer(gsub("V", "", id_t, fixed = TRUE))) %>%
    suppressWarnings()
  tab_[["id_s"]] <- .source[["id"]][tab_[["id_s"]]]
  tab_[["id_t"]] <- .target[["id"]][tab_[["id_t"]]]
  colnames(tab_) <- c("id_s", "id_t", paste0("sim_", .col))
  return(tab_)
}
```

### Example/Test
```{r example-match_col}
match_col(
  .source = table_source[1:100, ],
  .target = table_target[1:999, ],
  .col = "name",
  .max_match = 10,
  .min_sim = .2,
  .method = "osa"
)
```

```{r tests-match_col}
test_that("match_col works", {
  expect_true(inherits(match_col, "function")) 
})
```

## HELP: help_match_data
```{r dev-help_match_data}
.source = table_source[1:100, ]
.target = table_target[1:999, ]
.cols = c("name", "iso3", "city", "address")
.method = "osa"
.max_match = 10
.min_sim = 0
.progress = TRUE
.must_match = c("iso3")
```

### Function
```{r function-help_match_data}
#' Title
#' 
#' Description
#' 
#' @param .source 
#' The Source Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .target 
#' The Traget Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .cols 
#' The column names to match as character vector
#' @param .max_match 
#' Maximum number of matches to return (Default = 10)
#' @param .min_sim 
#' Minimum Similarity as defined by the chosen method
#' @param .method 
#' One of "osa", "lv", "dl", "hamming", "lcs", "qgram", "cosine", "jaccard", "jw", "soundex"
#' @param .must_match Columns that must be matched perfectly
#' @param .progress Should a progress bar be shown?
#' See stringdist package
#' @return A Dataframe
#' 
help_match_data <- function(.source, .target, .cols, .must_match = NULL, .max_match = 10, 
                       .min_sim = .8, .method = "osa", .progress = TRUE) {
  
  sim <- NULL
  
  if (!is.null(.must_match)) {
    vs_ <- tidyr::unite(.source[, .must_match], "tmp", dplyr::everything())[["tmp"]]
    ls_ <- split(.source, vs_)
    
    vt_ <- tidyr::unite(.target[, .must_match], "tmp", dplyr::everything())[["tmp"]]
    lt_ <- split(.target, vt_)
    
    lt_ <- lt_[names(lt_) %in% names(ls_)]
    ls_ <- ls_[names(lt_)]
  } else {
    ls_ <- list(.source)
    lt_ <- list(.target)
  }

  if (.progress) {
    pb <- progress::progress_bar$new(
      total = length(ls_),
      clear = FALSE, show_after = 1
      )
  }
  purrr::map2_dfr(
    .x = ls_,
    .y = lt_,
    .f = ~ {
      if (.progress) pb$tick()
      tab_ <- match_col(.x, .y, .cols[1], .max_match, .min_sim, .method)

      if (length(.cols) > 1) {
        s_ <- dplyr::left_join(tab_, .x, by = c("id_s" = "id"))
        t_ <- dplyr::left_join(tab_, .y, by = c("id_t" = "id"))

        for (i in 2:length(.cols)) {
          a <- stringdist::stringsim(s_[[.cols[i]]], t_[[.cols[i]]], .method)

          tab_[[paste0("sim_", .cols[i])]] <- stringdist::stringsim(s_[[.cols[i]]], t_[[.cols[i]]], .method)
        }
      }
      gc()
      return(tab_)
    }
  )
}
```

### Example/Test

```{r example-help_match_data, eval=FALSE}
help_match_data(
  .source = table_source[1:100, ], 
  .target = table_target[1:999, ], 
  .cols = c("name", "iso3", "city"), 
  .max_match = 10, 
  .min_sim = .2, 
  .must_match = "iso3",
  .method = "osa",
  .progress = TRUE
  )
```



```{r tests-help_match_data}
test_that("match_data works", {
  expect_true(inherits(help_match_data, "function")) 
})
```

## MAIN: match_data
```{r dev-match_data}
.source = table_source[1:100, ]
.target = table_target[1:999, ]
.cols = c("name", "iso3", "city", "address")
.method = "osa"
.max_match = 10
.min_sim = 0
.progress = TRUE
.must_match = c("iso3")
.chunk = 5
```

### Function
```{r function-match_data}
#' Title
#' 
#' Description
#' 
#' @param .source 
#' The Source Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .target 
#' The Traget Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .cols 
#' The column names to match as character vector
#' @param .max_match 
#' Maximum number of matches to return (Default = 10)
#' @param .min_sim 
#' Minimum Similarity as defined by the chosen method
#' @param .method 
#' One of "osa", "lv", "dl", "hamming", "lcs", "qgram", "cosine", "jaccard", "jw", "soundex"
#' @param .must_match Columns that must be matched perfectly
#' @param .progress Should a progress bar be shown?
#' See stringdist package
#' @param .chunk Chunk your data
#'
#' @return A dataframe
#' 
#' @export
match_data <- function(.source, .target, .cols, .must_match = NULL, .max_match = 10,
                            .min_sim = .8, .method = "osa", .chunk = 1, .progress = TRUE) {
  if (.chunk > 1) {
    ls_ <- split(
      x = .source,
      f = rep(1:.chunk, each = ceiling(nrow(.source) / .chunk))[1:nrow(.source)]
    )
  } else {
    ls_ <- list("1" = .source)
  }

  
  cols_ <- .cols[!.cols %in% .must_match]
  
  purrr::imap_dfr(
    .x = ls_,
    .f = ~ {
      if (.progress) cat("\rITERATION", .y)
      help_match_data(
        .source = .x,
        .target = .target,
        .cols = cols_,
        .must_match = .must_match,
        .max_match = .max_match,
        .min_sim = .min_sim,
        .method = .method,
        .progress = .progress
      )
    }
  )
}
```

### Example/Test
```{r example-match_data, eval=FALSE}
match_data(
  .source = table_source[1:100, ],
  .target = table_target[1:999, ],
  .cols = c("name", "iso3", "city"),
  .min_sim = .2,
  .max_match = 10,
  .must_match = "iso3",
  .chunk = 5, 
  .method = "osa", 
  .progress = TRUE
)
```

```{r tests-match_data}
test_that("match_data works", {
  expect_true(inherits(match_data, "function")) 
})
```

## HELP: uniqueness_vec
```{r dev-uniqueness_vec}
.vec <- source[["name"]][1:10]
```

### Function
```{r function-uniqueness_vec}
#' Uniquness/Rarity of a vector 
#' 
#' Description
#' 
#' @param .vec A character vector
#'
#' @return A numeric vector
#' 
#' @noRd
uniqueness_vec <- function(.vec) {
  l1_ <- stringi::stri_split_fixed(.vec, " ")
  v1_ <- unlist(l1_)
  v2_ <- as.integer(stats::ave(v1_, v1_, FUN = length))
  l2_ <- utils::relist(v2_, l1_)
  v3_ <- purrr::map_int(l2_, ~ sum(.x, na.rm = TRUE))
  
  1 - (v3_ / max(v3_))
}
```

### Example/Test
```{r example-uniqueness_vec, eval=FALSE}
uniqueness_vec(table_source[["name"]][1:10])
```

```{r tests-uniqueness_vec}
test_that("uniqueness_vec works", {
  expect_true(inherits(uniqueness_vec, "function")) 
})
```

## MAIN: uniqueness_data
```{r dev-uniqueness_data}
.data <- table_source
.cols <- c("name", "city", "address")
.type <- "source"
```

### Function
```{r function-uniqueness_data}
#' Title
#' 
#' Description
#' 
#' @param .data A Dataframe
#' @param .cols Column as character vector
#' @param .type either source or target
#'
#' @return A dataframe
#' 
#' @export
uniqueness_data <- function(.data, .cols, .type = c("source", "target")) {
  id <- tmp <- NULL
  type_ <- match.arg(.type, c("source", "target"))
  type_ <- substr(type_, 1, 1)
  tab_ <- .data[, c("id", .cols)] %>%
    tidyr::unite(tmp, !dplyr::matches("^id$"))
  tab_[[paste0("uni_", type_)]] <- uniqueness_vec(tab_[["tmp"]])
  tab_ <- dplyr::select(tab_, -tmp)
  colnames(tab_) <- c(paste0("id_", type_), paste0("uni_", type_))
  return(tab_)
}
```

### Example/Test
```{r example-uniqueness_data, eval=FALSE}
uniqueness_data(table_source[1:100, ], c("name", "iso3", "city", "address"), "source")
```

```{r tests-uniqueness_data}
test_that("uniqueness_data works", {
  expect_true(inherits(uniqueness_data, "function")) 
})
```

## MAIN: scores_data
```{r dev-scores_data}
.data <- match_data(
  .source = table_source[1:100, ],
  .target = table_target[1:999, ],
  .cols = c("name", "iso3", "city"),
  .min_sim = .2,
  .max_match = 10,
  .must_match = "iso3",
  .method = "osa", 
  .progress = FALSE
)
.weights <- c(.8, 0, .2)
```

### Function
```{r function-scores_data}
#' Score Data
#' 
#' Description
#' 
#' @param .data A dataframe
#' @param .weights Custom weights
#' @param .training A training dataset
#'
#' @return A dataframe
#' 
#' @export
scores_data <- function(.data, .weights = NULL, .training = NULL) {
  id_s <- id_t <- NULL
  tab_ <- .data
  cols_ <- colnames(tab_)
  cols_ <- cols_[grepl("^sim_|^uni_", cols_)]
  mat_ <- as.matrix(tab_[, cols_])
  
  if (!is.null(.weights)) {
    mat_ <- mat_ * .weights
    tab_ %>%
      dplyr::select(id_s, id_t) %>%
      dplyr::mutate(
        score_mean = rowSums(mat_, na.rm = TRUE),
        score_square = rowSums(mat_^2, na.rm = TRUE)
      )
  } else {
    tab_ %>%
      dplyr::select(id_s, id_t) %>%
      dplyr::mutate(
        score_mean = rowMeans(mat_, na.rm = TRUE),
        score_square = rowMeans(mat_^2, na.rm = TRUE)
      )
  }
  
  

  
}
```

### Example/Test
```{r example-scores_data, eval=FALSE}
tab_match <- match_data(
  .source = table_source[1:100, ],
  .target = table_target[1:999, ],
  .cols = c("name", "iso3", "city"),
  .min_sim = .2,
  .max_match = 10,
  .method = "osa", 
  .progress = TRUE
)
tab_score <- scores_data(tab_match)
```

```{r tests-scores_data}
test_that("scores_data works", {
  expect_true(inherits(scores_data, "function")) 
})
```

## MAIN: dedup_data
```{r dev-dedup_data}
tab_match <- match_data(
  .source = table_source[1:100, ],
  .target = table_target[1:999, ],
  .cols = c("name", "iso3", "city"),
  .min_sim = .2,
  .max_match = 10,
  .method = "osa", 
  .progress = TRUE
)
.score <- scores_data(tab_match)
.source <- table_source
.target <- table_target
.col <- "score_mean"
```

### Function
```{r function-dedup_data}
#' Deduplicate Data
#' 
#' Description
#' 
#' @param .score Dataframe generated by scores_data()
#' @param .source 
#' The Source Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .target 
#' The Traget Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .col score column generated by scores_data()
#'
#' @return A dataframe
#' 
#' @export
dedup_data <- function(.score, .source, .target, .col) {
  id_s <- id_t <- name_s <- name_t <- NULL
  
  col_s_ <- colnames(.source)
  col_t_ <- colnames(.target)
  col_e_ <- col_s_[col_s_ %in% col_t_]
  col_e_ <- col_e_[!col_e_ == "id"]
  col_e_ <- unlist(purrr::map2(paste0(col_e_, "_s"), paste0(col_e_, "_t"), c))
  
  tab_ <- .score %>%
    dplyr::select(id_s, id_t, !!dplyr::sym(.col)) %>%
    dplyr::arrange(dplyr::desc(!!dplyr::sym(.col))) %>%
    dplyr::filter(!duplicated(id_t)) %>%
    dplyr::distinct(id_s, .keep_all = TRUE) %>%
    dplyr::full_join(.source, c("id_s" = "id"), FALSE, suffix = c("_s", "_t")) %>%
    dplyr::left_join(.target, c("id_t" = "id"), FALSE, suffix = c("_s", "_t"))
  
  tab_ <- tab_[, c("id_s", "id_t", .col, col_e_)]
  colnames(tab_) <- c("id_s", "id_t", "score", col_e_)
  return(tab_)
}
```

### Example/Test
```{r example-dedup_data, eval=FALSE}
tab_source <- table_source[1:100, ]
tab_target <- table_target[1:999, ]
tab_match <- match_data(
  .source = table_source[1:100, ],
  .target = table_target[1:999, ],
  .cols = c("name", "iso3", "city"),
  .min_sim = .2,
  .max_match = 10,
  .method = "osa", 
  .progress = TRUE
)
tab_score <- scores_data(tab_match)
dedup_data(tab_score, tab_source, tab_target, "score_mean")
```

```{r tests-dedup_data}
test_that("dedup_data works", {
  expect_true(inherits(dedup_data, "function")) 
})
```

# Inflate your package

You're one inflate from paper to box. Build your package from this very Rmd using `fusen::inflate()`

-   Verify your `"DESCRIPTION"` file has been updated
-   Verify your function is in `"R/"` directory
-   Verify your test is in `"tests/testthat/"` directory
-   Verify this Rmd appears in `"vignettes/"` directory

```{r development-inflate, eval=FALSE}
fusen::inflate(
  flat_file = "dev/flat_full.Rmd", 
  vignette_name = NA, overwrite = TRUE
  )
```
