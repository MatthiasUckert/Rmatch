---
title: "flat_full.Rmd for working package"
output: html_document
editor_options: 
  chunk_output_type: console
---

<!-- Run this 'development' chunk -->

<!-- Store every call to library() that you need to explore your functions -->

```{r development, include=FALSE}
library(testthat); library(tidyverse); library(stringi); library(fst)
```

```{r development-2}
pkgload::load_all(path = here::here(), export_all = FALSE)
```

# Functions

## HELP: standardize_str
```{r dev-standardize_str}
.str <- "International Business Corporation"
.op = c("space", "punct", "case", "utf8")
```

### Function

```{r function-standardize_str}
#' Standardize Strings
#' 
#' Description
#' 
#' @param .str A string
#' @param .op Operations to perform
#'
#' @return A string
#' 
#' @export
standardize_str <- function(.str, .op = c("space", "punct", "case", "utf8")) {
  str_ <- .str
  
  if ("punct" %in% .op) {
    str_ <- trimws(stringi::stri_replace_all_regex(str_, "\\W", " "))
    str_ <- trimws(stringi::stri_replace_all_regex(str_, "[[:punct:]]", " "))
    
    if (!"space" %in% .op) {
      str_ <- trimws(stringi::stri_replace_all_regex(str_, "([[:blank:]]|[[:space:]])+", " "))
    }
  }
  
  if ("space" %in% .op) {
    str_ <- trimws(stringi::stri_replace_all_regex(str_, "([[:blank:]]|[[:space:]])+", " "))
  }
  
  if ("case" %in% .op) {
    str_ <- toupper(str_)
  }
  
  if ("utf8" %in% .op) {
    str_ <- stringi::stri_enc_toutf8(str_)
  }
  
  return(str_)
  
}
```

### Example/Test
```{r example-standardize_str, eval=FALSE}
standardize_str(c("jkldsa   jkdhas   äää  §$ ## #'''"))
```

```{r tests-standardize_str}
test_that("standardize_str works", {
  expect_true(inherits(standardize_str, "function")) 
})
```

## MAIN: standardize_data
```{r dev-standardize_data}
.data <- table_source
.cols <- c("name", "iso3", "city", "address")
.op = c("space", "punct", "case", "utf8")
```

### Function
```{r function-standardize_data}
#' Standardize Data
#' 
#' Description
#' 
#' @param .data A dataframe
#' @param .cols Columns to standardize
#' @param .fun Function for standardization, if NULL standardize_str() is used
#'
#' @return A dataframe
#' 
#' @export
standardize_data <- function(.data, .cols, .fun = NULL) {
  tab_ <- tibble::as_tibble(.data)
  if (is.null(.fun)) {
    f_ <- standardize_str
  } else {
    f_ <- .fun
  }
  
  for (i in .cols) {
    tab_[[i]] <- f_(tab_[[i]])
  }
  return(tab_)
}
```

### Example/Test
```{r example-standardize_data, eval=FALSE}
standardize_data(table_source, c("name", "iso3", "city", "address"))
```

```{r tests-standardize_data}
test_that("standardize_data works", {
  expect_true(inherits(standardize_data, "function")) 
})
```

## MAIN: extract_legal_form
```{r dev-extract_legal_form}
.data <- table_source
.col <- "name"
.legal_forms <- tibble(.rows = 0)
.workers = future::availableCores()
```

### Function
```{r function-extract_legal_form}
#' Extract Legal Forms
#' 
#' Description
#' 
#' @param .data A dataframe
#' @param .col The column with firm names
#' @param .legal_forms A dataframe with legal forms
#' @param .workers Number of cores
#'
#' @return A dataframe
#' 
#' @importFrom rlang :=
#' 
#' @export
extract_legal_form <- function(.data, .col, .legal_forms = data.frame(), .workers = future::availableCores()) {
  tmp <- legal_form_orig <- legal_form_stand <- legal_form <- name <- NULL
  
  .data <- tibble::as_tibble(.data)
  
  if (nrow(.legal_forms) == 0) {
    tab_lf_ <- get("legal_form_all")
  } else {
    tab_lf_ <- .legal_forms
  }

  tab_ <- standardize_data(.data, .col)
  lf_ <- unique(tab_lf_[["legal_form_orig"]])
  nm_ <- tab_[[.col]]

  f_ <- carrier::crate(function(.lf, .nm) which(endsWith(.nm, paste0(" ", .lf))))
  future::plan("multisession", workers = 6)
  lf_ext_ <- furrr::future_map(
    .x = purrr::set_names(lf_, lf_),
    .f = ~ f_(.x, nm_),
    .options = furrr::furrr_options(seed = TRUE)
  )
  future::plan("default")
  lf_ext_ <- lf_ext_ %>%
    purrr::compact() %>%
    tibble::enframe(name = "legal_form_orig", value = "tmp") %>%
    tidyr::unnest(tmp) %>%
    dplyr::arrange(dplyr::desc(nchar(legal_form_orig))) %>%
    dplyr::distinct(tmp, .keep_all = TRUE)

  tab_ %>%
    dplyr::mutate(tmp = dplyr::row_number()) %>%
    dplyr::left_join(lf_ext_, by = "tmp") %>%
    dplyr::left_join(tab_lf_, by = c("iso3", "legal_form_orig")) %>%
    dplyr::rename(legal_form = legal_form_stand) %>%
    dplyr::relocate(legal_form, .after = !!dplyr::sym(.col)) %>%
    dplyr::mutate(
      !!dplyr::sym(paste0(.col, "_adj")) := trimws(
        stringi::stri_replace_last_fixed(name, legal_form_orig, "")
      ),
      .after = !!dplyr::sym(.col)
    ) %>%
    dplyr::mutate(
      !!dplyr::sym(paste0(.col, "_adj")) := dplyr::if_else(
        condition = is.na(!!dplyr::sym(paste0(.col, "_adj"))),
        true = !!dplyr::sym(.col), 
        false = !!dplyr::sym(paste0(.col, "_adj"))
        )) %>%
    dplyr::mutate(
      !!dplyr::sym(paste0(.col, "_std")) := dplyr::if_else(
        condition = !is.na(legal_form),
        true = paste(!!dplyr::sym(paste0(.col, "_adj")), legal_form),
        false = !!dplyr::sym(paste0(.col, "_adj"))
      ),
      .after = !!dplyr::sym(paste0(.col, "_adj"))
    ) %>%
    dplyr::select(-legal_form_orig, -tmp)
  
  
}
```

### Example/Test
```{r example-extract_legal_form, eval=FALSE}
extract_legal_form(table_source[1:100, ], "name", .workers = 1)
```

```{r tests-extract_legal_form}
test_that("extract_legal_form works", {
  expect_true(inherits(extract_legal_form, "function")) 
})
```

## HELP: match_col
```{r dev-match_col}
.source <- bind_rows(table_source[1:100, ], table_source[1:100, ])
.target <- table_target[1:999, ]
.col <- "name"
.method = "osa"
.max_match = 10
.min_sim = 0
```

### Function

```{r function-match_col}
#' Match a on a single column
#' 
#' Description
#' 
#' @param .source 
#' The Source Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .target 
#' The Target Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .col 
#' The column name to match as a string
#' @param .max_match 
#' Maximum number of matches to return (Default = 10)
#' @param .min_sim 
#' Minimum Similarity as defined by the chosen method
#' @param .method 
#' One of "osa", "lv", "dl", "hamming", "lcs", "qgram", "cosine", "jaccard", "jw", "soundex"
#' See stringdist package
#' @param .workers Number of cores
#'
#' @return A Dataframe
match_col <- function(.source, .target, .col, .max_match = 10, 
                      .min_sim = .2, .method = "osa", .workers = future::availableCores()) {
  V1 <- value <- id <- name <- id_t <- sim <- NULL
  .source <- tibble::as_tibble(.source)
  .target <- tibble::as_tibble(.target)
  
  
  check_id(.source, .target)
  
  method_ <- match.arg(
    arg = .method,
    choices = c(
      "osa", "lv", "dl", "hamming", "lcs", "qgram", "cosine",
      "jaccard", "jw", "soundex"
    )
  )
  
  tab_ <- stringdist::stringsimmatrix(
    a = .source[[.col]],
    b = .target[[.col]],
    method = method_,
    nthread = .workers
  ) %>%
    tibble::as_tibble() %>%
    dplyr::mutate(id = dplyr::row_number(), .before = V1) %>%
    tidyr::pivot_longer(!dplyr::matches("id")) %>%
    dplyr::filter(value >= .min_sim) %>%
    dplyr::group_by(id) %>%
    dplyr::slice_max(order_by = value, n = .max_match) %>%
    dplyr::ungroup() %>%
    dplyr::rename(id_s = id, id_t = name) %>%
    dplyr::mutate(id_t = as.integer(gsub("V", "", id_t, fixed = TRUE))) %>%
    suppressWarnings()
  tab_[["id_s"]] <- .source[["id"]][tab_[["id_s"]]]
  tab_[["id_t"]] <- .target[["id"]][tab_[["id_t"]]]
  colnames(tab_) <- c("id_s", "id_t", paste0("sim_", .col))
  return(tab_)
}
```

### Example/Test
```{r example-match_col}
match_col(
  .source = table_source[1:100, ],
  .target = table_target[1:999, ],
  .col = "name",
  .max_match = 10,
  .min_sim = .2,
  .method = "osa"
)
```

```{r tests-match_col}
test_that("match_col works", {
  expect_true(inherits(match_col, "function")) 
})
```

## HELP: help_match_data
```{r dev-help_match_data}
.source = bind_rows(table_source[1:100, ], table_source[1:100, ])
.target = table_target[1:999, ]
.cols = c("name", "iso3", "city", "address")
.method = "osa"
.max_match = 10
.min_sim = 0
.progress = TRUE
.must_match = c("iso3")
```

### Function
```{r function-help_match_data}
#' Match Data
#' 
#' Description
#' 
#' @param .source 
#' The Source Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .target 
#' The Target Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .cols 
#' The column names to match as character vector
#' @param .max_match 
#' Maximum number of matches to return (Default = 10)
#' @param .min_sim 
#' Minimum Similarity as defined by the chosen method
#' @param .method 
#' One of "osa", "lv", "dl", "hamming", "lcs", "qgram", "cosine", "jaccard", "jw", "soundex"
#' @param .must_match Columns that must be matched perfectly
#' @param .progress Should a progress bar be shown?
#' See stringdist package
#' @param .workers Number of cores
#' 
#' @return A Dataframe
#' 
help_match_data <- function(.source, .target, .cols, .must_match = NULL, .max_match = 10,
                            .min_sim = .2, .method = "osa", .progress = TRUE,
                            .workers = future::availableCores()) {
  sim <- NULL
  .source <- tibble::as_tibble(.source)
  .target <- tibble::as_tibble(.target)

  check_id(.source, .target)

  if (!is.null(.must_match)) {
    vs_ <- tidyr::unite(.source[, .must_match], "tmp", dplyr::everything())[["tmp"]]
    ls_ <- split(.source, vs_)

    vt_ <- tidyr::unite(.target[, .must_match], "tmp", dplyr::everything())[["tmp"]]
    lt_ <- split(.target, vt_)

    lt_ <- lt_[names(lt_) %in% names(ls_)]
    ls_ <- ls_[names(lt_)]
  } else {
    ls_ <- list(.source)
    lt_ <- list(.target)
  }

  if (.progress) {
    pb <- progress::progress_bar$new(
      total = length(ls_),
      clear = FALSE, show_after = 1
    )
  }
  purrr::map2_dfr(
    .x = ls_,
    .y = lt_,
    .f = ~ {
      if (.progress) pb$tick()
      tab_ <- match_col(
        .source = .x,
        .target = .y,
        .col = .cols[1],
        .max_match = .max_match,
        .min_sim = .min_sim,
        .method = .method,
        .workers = .workers
      )

      if (length(.cols) > 1) {
        s_ <- dplyr::left_join(tab_, .x, by = c("id_s" = "id"))
        t_ <- dplyr::left_join(tab_, .y, by = c("id_t" = "id"))

        for (i in 2:length(.cols)) {
          tab_[[paste0("sim_", .cols[i])]] <- stringdist::stringsim(s_[[.cols[i]]], t_[[.cols[i]]], .method)
        }
      }
      return(tab_)
    }
  )
}
```

### Example/Test

```{r example-help_match_data, eval=FALSE}
help_match_data(
  .source = table_source[1:100, ], 
  .target = table_target[1:999, ], 
  .cols = c("name", "iso3", "city"), 
  .max_match = 10, 
  .min_sim = .2, 
  .must_match = "iso3",
  .method = "osa",
  .progress = TRUE
  )
```



```{r tests-help_match_data}
test_that("match_data works", {
  expect_true(inherits(help_match_data, "function")) 
})
```

## MAIN: join_data
### Function
```{r dev-join_data}
.source = table_source[1:100, ]
.target = table_target[1:999, ]
.cols = c("name", "iso3", "city", "address")
.join <- c("name", "iso3")
.method = "osa"
```

```{r function-join_data}
#' Perform LeftJoin on Data
#' 
#' Description
#' 
#' @param .source 
#' The Source Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .target 
#' The Target Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .cols 
#' The column names to match as character vector
#' @param .join
#' Columns to match on
#' @param .method 
#' One of "osa", "lv", "dl", "hamming", "lcs", "qgram", "cosine", "jaccard", "jw", "soundex"
#' @return A Dataframe
#' 
#' @export
join_data <- function(.source, .target, .cols, .join, .method = "osa") {
  id_s <- id_t <- NULL
  .source <- tibble::as_tibble(.source)
  .target <- tibble::as_tibble(.target)
  
  check_id(.source, .target)
  
  s_ <- .source[, c("id", .join)]
  t_ <- .target[, c("id", .join)]
  non_ <- .cols[!.cols %in% .join]

  tab_ <- dplyr::inner_join(s_, t_, by = .join, suffix = c("_s", "_t")) %>%
    dplyr::mutate(
      dplyr::across(!dplyr::matches("^id_s$|^id_t$"), ~1)
    ) %>%
    dplyr::select(id_s, id_t, dplyr::everything()) %>%
    `colnames<-`(c("id_s", "id_t", paste0("sim_", .join)))

  s_ <- dplyr::left_join(tab_, .source[, c("id", non_)], by = c("id_s" = "id"))
  t_ <- dplyr::left_join(tab_, .target[, c("id", non_)], by = c("id_t" = "id"))

  for (i in seq_len(length(non_))) {
    tab_[[paste0("sim_", non_[i])]] <- stringdist::stringsim(s_[[non_[i]]], t_[[non_[i]]], .method)
  }
  
  return(tab_)
}
```

### Example/Test
```{r example-join_data}
join_data(
  .source = table_source,
  .target = table_target,
  .cols = c("name", "iso3", "city", "address"),
  .join = c("name", "iso3"),
  .method = "osa"
)
```
  
```{r tests-join_data}
test_that("join_data works", {
  expect_true(inherits(join_data, "function")) 
})
```
  

## MAIN: match_data
```{r dev-match_data}
.source = table_source[1:100, ]
.target = table_target[1:999, ]
.cols = c("name", "iso3", "city", "address")
.join = c("name", "iso3")
.method = "osa"
.max_match = 10
.min_sim = 0
.progress = TRUE
.must_match = c("iso3")
.chunk = 5
```

### Function
```{r function-match_data}
#' Match Data
#' 
#' Description
#' 
#' @param .source 
#' The Source Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .target 
#' The Target Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .cols 
#' The column names to match as character vector
#' @param .join
#' Columns to match on
#' @param .max_match 
#' Maximum number of matches to return (Default = 10)
#' @param .min_sim 
#' Minimum Similarity as defined by the chosen method
#' @param .method 
#' One of "osa", "lv", "dl", "hamming", "lcs", "qgram", "cosine", "jaccard", "jw", "soundex"
#' @param .must_match Columns that must be matched perfectly
#' @param .progress Should a progress bar be shown?
#' See stringdist package
#' @param .chunk Chunk your data
#' @param .workers Number of cores
#' @return A dataframe
#' 
#' @export
match_data <- function(.source, .target, .cols, .join = NULL, .must_match = NULL, .max_match = 10,
                       .min_sim = .2, .method = "osa", .chunk = 1, .progress = TRUE,
                       .workers = future::availableCores()) {
  id <- NULL
  .source <- tibble::as_tibble(.source)
  .target <- tibble::as_tibble(.target)
  
  
  check_id(.source, .target)
  
  if (!is.null(.join)) {
    tab0_ <- join_data(.source, .target, .cols, .join)
    s_ <- dplyr::filter(.source, !id %in% tab0_$id_s)
    t_ <- dplyr::filter(.target, !id %in% tab0_$id_t)
  } else {
    tab0_ <- tibble::tibble(id_s = "", .rows = 0)
    s_ <- .source
    t_ <- .target
  }


  if (.chunk > 1) {
    ls_ <- split(
      x = s_,
      f = rep(1:.chunk, each = ceiling(nrow(s_) / .chunk))[1:nrow(s_)]
    )
  } else {
    ls_ <- list("1" = s_)
  }


  tab1_ <- purrr::imap_dfr(
    .x = ls_,
    .f = ~ {
      if (.progress) cat("\rITERATION", .y)
      help_match_data(
        .source = .x,
        .target = t_,
        .cols = .cols,
        .must_match = .must_match,
        .max_match = .max_match,
        .min_sim = .min_sim,
        .method = .method,
        .progress = .progress, 
        .workers = .workers
      )
    }
  )

  out_ <- dplyr::bind_rows(tab0_, tab1_)
  out_ <- out_[, c("id_s", "id_t", paste0("sim_", .cols))]
  
}
```

### Example/Test
```{r example-match_data, eval=FALSE}
tab_source <- table_source[1:100, ]
tab_target <- table_target[1:999, ]
cols <- c("name", "iso3", "city", "address")
must <- "iso3"
match_data(
  .source = tab_source,
  .target = tab_target,
  .cols = cols,
  .must_match = must,
)
```

```{r tests-match_data}
test_that("match_data works", {
  expect_true(inherits(match_data, "function")) 
})
```

## HELP: uniqueness_vec
```{r dev-uniqueness_vec}
.vec <- standardize_str(table_source[["name"]])
```

### Function
```{r function-uniqueness_vec}
#' Uniquness/Rarity of a vector 
#' 
#' Description
#' 
#' @param .vec A character vector
#' @param .normalize Normalize between 0 and 1
#'
#' @return A numeric vector
#' 
#' @noRd
uniqueness_vec <- function(.vec, .normalize = FALSE) {
  value <- name <- n <- NULL
  
  l1_ <- stringi::stri_split_fixed(.vec, " ")
  v1_ <- unlist(l1_)
  v1_ <- as.integer(stats::ave(v1_, v1_, FUN = length))
  l1_ <- utils::relist(v1_, l1_)
  v1_ <- purrr::map_dbl(l1_, ~ mean(.x, na.rm = TRUE))
  
  v2_ <- as.integer(stats::ave(.vec, .vec, FUN = length))
  
  1 / ((v1_ + v2_) / 2)
}
```



### Example/Test
```{r example-uniqueness_vec, eval=FALSE}
mean(uniqueness_vec(table_source[["name"]], TRUE), na.rm = TRUE) 
mean(uniqueness_vec(table_source[["iso3"]], TRUE), na.rm = TRUE)
mean(uniqueness_vec(table_source[["city"]], TRUE), na.rm = TRUE)
mean(uniqueness_vec(table_source[["address"]], TRUE), na.rm = TRUE)
```

```{r tests-uniqueness_vec}
test_that("uniqueness_vec works", {
  expect_true(inherits(uniqueness_vec, "function")) 
})
```


## MAIN: get_weights
### Function

```{r dev-get_weights}
.data <- table_source
.cols <- c("name", "city", "address")
```


```{r function-get_weights}
#' Get Weights
#' 
#' Description
#' 
#' @param .data A Dataframe
#' @param .cols columns
#'
#' @return A numeric vector
#' 
#' @export
get_weights <- function(.data, .cols) {
  . <- NULL
  purrr::map_dbl(
    .x = stats::setNames(.cols, .cols), 
    .f = ~ mean(uniqueness_vec(.data[[.x]]), na.rm = TRUE)
    ) %>% `/`(sum(., na.rm = TRUE))
}
```


### Example Test
```{r example-get_weights}
get_weights(table_source, c("name", "city", "address"))
```
  
```{r tests-get_weights}
test_that("get_weights works", {
  expect_true(inherits(get_weights, "function")) 
})
```
  
<!-- ## MAIN: uniqueness_data -->
<!-- ```{r dev-uniqueness_data} -->
<!-- .data <- table_source -->
<!-- .cols <- c("name", "city", "address") -->
<!-- .type <- "source" -->
<!-- ``` -->

<!-- ### Function -->
<!-- ```{r function-uniqueness_data} -->
<!-- #' Calculate Uniqueness of Data -->
<!-- #'  -->
<!-- #' Description -->
<!-- #'  -->
<!-- #' @param .data A Dataframe -->
<!-- #' @param .cols Column as character vector -->
<!-- #' @param .type either source or target -->
<!-- #' -->
<!-- #' @return A dataframe -->
<!-- #'  -->
<!-- #' @export -->
<!-- uniqueness_data <- function(.data, .cols, .type = c("source", "target")) { -->
<!--   id <- tmp <- NULL -->
<!--   .dat <- tibble::as_tibble(.data) -->

<!--   type_ <- match.arg(.type, c("source", "target")) -->
<!--   type_ <- substr(type_, 1, 1) -->
<!--   tab_ <- .data[, c("id", .cols)] %>% -->
<!--     tidyr::unite(tmp, !dplyr::matches("^id$")) -->
<!--   tab_[[paste0("uni_", type_)]] <- uniqueness_vec(tab_[["tmp"]]) -->
<!--   tab_ <- dplyr::select(tab_, -tmp) -->
<!--   colnames(tab_) <- c(paste0("id_", type_), paste0("uni_", type_)) -->
<!--   return(tab_) -->
<!-- } -->
<!-- ``` -->

<!-- ### Example/Test -->
<!-- ```{r example-uniqueness_data, eval=FALSE} -->
<!-- uniqueness_data(table_source[1:100, ], c("name", "iso3", "city", "address"), "source") -->
<!-- ``` -->

<!-- ```{r tests-uniqueness_data} -->
<!-- test_that("uniqueness_data works", { -->
<!--   expect_true(inherits(uniqueness_data, "function"))  -->
<!-- }) -->
<!-- ``` -->

## HELP: help_check_weights
    
```{r function-help_check_weights}
#' Check Weights
#'
#' @param .weights weights 
#' @param .cols columns
#'
#' @return Error
help_check_weights <- function(.weights = NULL, .cols = NULL) {
  if (!is.null(.weights)) {
    nw_ <- sort(names(.weights)); nc_ <- sort(.cols)
    lw_ <- length(nw_); lc_ <- length(nc_)
    
    if (lw_ == 0) stop(".weights must be a named vector")
    if (!lw_ == lc_) stop(".weights and .cols must have the same length")
    if (!all(nw_ == nc_)) stop(".weights and .cols must have the same names")
  }
}
```
  
```{r example-help_check_weights}
# help_check_weights()
```
  
```{r tests-help_check_weights}
test_that("help_check_weights works", {
  expect_true(inherits(help_check_weights, "function")) 
})
```
  

## MAIN: scores_data
```{r dev-scores_data}
.matches <- match_data(
  .source = table_source[1:100, ],
  .target = table_target[1:999, ],
  .cols = c("name", "iso3", "city", "address"),
  .min_sim = .2,
  .max_match = 10,
  .must_match = "iso3",
  .method = "osa", 
  .progress = FALSE
)
.source <- table_source[1:100, ]
.target <- table_target[1:999, ]
.w_unique <- NULL
.w_custom <- c(name = .6, city = .1, address = .3)
.must_match = "iso3"
```

### Function
```{r function-scores_data}
#' Score Data
#' 
#' Description
#' 
#' @param .matches Dataframe produced by match_data()
#' @param .source 
#' The Source Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .target 
#' The Target Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .must_match Columns that must be matched perfectly
#' @param .w_unique Weights calucalted by get_weights()
#' @param .w_custom Custom weights
#'
#' @return A dataframe
#' 
#' @export
scores_data <- function(.matches, .source, .target, .must_match = NULL, 
                        .w_unique = NULL, .w_custom = NULL) {
  id_s <- id_t <- . <- NULL
  
  .matches <- tibble::as_tibble(.matches)
  .source  <- tibble::as_tibble(.source)
  .target  <- tibble::as_tibble(.target)
  
  cols_ <- colnames(.matches)
  cols_ <- gsub("sim_", "", cols_[grepl("^sim_", cols_)])
  cols_ <- cols_[!cols_ %in% .must_match]
  
  if (!is.null(.w_unique)) {
    help_check_weights(.w_unique, cols_)
    wu_ <- .w_unique
  } else {
    wu_ <- (get_weights(.source, cols_) + get_weights(.target, cols_)) / 2
  }
  
  if (!is.null(.w_custom)) {
    help_check_weights(.w_custom, cols_)
    wc_ <- .w_custom[order(match(names(.w_custom), cols_))]
    wc_ <- wc_ / sum(wc_)
  } else {
    wc_ <- rep(NA_real_, length(cols_))
  }

  mat_ <- as.matrix(.matches[, paste0("sim_", cols_)])
  
  .matches %>%
    dplyr::select(id_s, id_t, dplyr::starts_with("sim_")) %>%
    dplyr::mutate(
      mean_simple = rowMeans(mat_, na.rm = TRUE),
      mean_weight = rowSums(mat_ * wu_, na.rm = TRUE),
      mean_custom = rowSums(mat_ * wc_, na.rm = TRUE)
    )
}
```

### Example/Test
```{r example-scores_data, eval=FALSE}
tab_source <- table_source[1:100, ]
tab_target <- table_target[1:999, ]
cols <- c("name", "iso3", "city", "address")
must <- "iso3"
tab_match <- match_data(
  .source = tab_source,
  .target = tab_target,
  .cols = cols,
  .must_match = must,
)
scores_data(
  .matches = tab_match,
  .source = tab_source,
  .target = tab_target,
  .must_match = must
)
```

```{r tests-scores_data}
test_that("scores_data works", {
  expect_true(inherits(scores_data, "function")) 
})
```

## MAIN: dedup_data
```{r dev-dedup_data}
tab_source <- table_source[1:100, ]
tab_target <- table_target[1:999, ]
cols <- c("name", "iso3", "city", "address")
must <- "iso3"
tab_match <- match_data(
  .source = tab_source,
  .target = tab_target,
  .cols = cols,
  .must_match = must,
)
.score <- scores_data(
  .matches = tab_match, 
  .source = table_source, 
  .target = table_target, 
  .must_match = "iso3"
  )
.source <- table_source
.target <- table_target
.col <- "weight_mean"
```

### Function
```{r function-dedup_data}
#' Deduplicate Data
#' 
#' Description
#' 
#' @param .score Dataframe generated by scores_data()
#' @param .source 
#' The Source Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .target 
#' The Target Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .col score column generated by scores_data()
#'
#' @return A dataframe
#' 
#' @export
dedup_data <- function(.score, .source, .target, .col = "mean_weight") {
  id_s <- id_t <- name_s <- name_t <- NULL
  .score  <- tibble::as_tibble(.score)
  .source <- tibble::as_tibble(.source)
  .target <- tibble::as_tibble(.target)
  
  
  col_s_ <- colnames(.source)
  col_t_ <- colnames(.target)
  col_e_ <- col_s_[col_s_ %in% col_t_]
  col_e_ <- col_e_[!col_e_ == "id"]
  col_e_ <- unlist(purrr::map2(paste0(col_e_, "_s"), paste0(col_e_, "_t"), c))
  
  tab_ <- .score %>%
    dplyr::select(id_s, id_t, !!dplyr::sym(.col)) %>%
    dplyr::arrange(dplyr::desc(!!dplyr::sym(.col))) %>%
    dplyr::filter(!duplicated(id_t)) %>%
    dplyr::distinct(id_s, .keep_all = TRUE) %>%
    dplyr::full_join(.source, c("id_s" = "id"), FALSE, suffix = c("_s", "_t")) %>%
    dplyr::left_join(.target, c("id_t" = "id"), FALSE, suffix = c("_s", "_t"))
  
  tab_ <- tab_[, c("id_s", "id_t", .col, col_e_)]
  colnames(tab_) <- c("id_s", "id_t", "score", col_e_)
  return(tab_)
}
```

### Example/Test
```{r example-dedup_data, eval=FALSE}
tab_source <- table_source[1:100, ]
tab_target <- table_target[1:999, ]
cols <- c("name", "iso3", "city", "address")
must <- "iso3"
tab_match <- match_data(
  .source = tab_source,
  .target = tab_target,
  .cols = cols,
  .must_match = must,
)
tab_score <- scores_data(
  .matches = tab_match,
  .source = tab_source,
  .target = tab_target,
  .must_match = must
)

dedup_data(
  .score = tab_score, 
  .source = tab_source, 
  .target = tab_target, 
  )
```

```{r tests-dedup_data}
test_that("dedup_data works", {
  expect_true(inherits(dedup_data, "function")) 
})
```

# Inflate your package

You're one inflate from paper to box. Build your package from this very Rmd using `fusen::inflate()`

-   Verify your `"DESCRIPTION"` file has been updated
-   Verify your function is in `"R/"` directory
-   Verify your test is in `"tests/testthat/"` directory
-   Verify this Rmd appears in `"vignettes/"` directory

```{r development-inflate, eval=FALSE}
fusen::inflate(
  flat_file = "dev/flat_full.Rmd", 
  vignette_name = NA, 
  overwrite = TRUE,
  check = FALSE
  )
devtools::check(vignettes = FALSE)
```
