---
title: "flat_full.Rmd for working package"
output: html_document
editor_options: 
  chunk_output_type: console
---

<!-- Run this 'development' chunk -->
<!-- Store every call to library() that you need to explore your functions -->

```{r development, include=FALSE}
library(testthat); library(tidyverse); library(stringi); library(fst)
```

<!--
 You need to run the 'description' chunk in the '0-dev_history.Rmd' file before continuing your code there.

If it is the first time you use {fusen}, after 'description', you can directly run the last chunk of the present file with inflate() inside.
--> 

```{r development-2}
pkgload::load_all(path = here::here(), export_all = FALSE)
```

# Datasets
```{r function-source, filename = "datasets"}
#' Example Dataset: Source
#'
#'
#' @format A data frame with 2,426 rows and 5 variables:
#' \describe{
#'   \item{id}{A unique identifier}
#'   \item{name}{Company name}
#'   \item{iso3}{ISO 3166-1 alpha-3 country codes}
#'   \item{city}{City Name}
#'   \item{address}{Address Name}
#' }
"source"
```

```{r function-target, filename = "datasets"}
#' Example Dataset: Target
#'
#'
#' @format A data frame with 4,671 rows and 5 variables:
#' \describe{
#'   \item{id}{A unique identifier}
#'   \item{name}{Company name}
#'   \item{iso3}{ISO 3166-1 alpha-3 country codes}
#'   \item{city}{City Name}
#'   \item{address}{Address Name}
#' }
"target"
```

```{r function-matches, filename = "datasets"}
#' Example Dataset: Matches
#'
#'
#' @format A data frame with 2,426 rows and 11 variables:
#' \describe{
#'   \item{id_s}{Source Dataframe: A unique identifier}
#'   \item{id_t}{Traget Dataframe: A unique identifier}
#'   \item{name_s}{Source Dataframe: Company name}
#'   \item{name_t}{Traget Dataframe: Company name}
#'   \item{iso3_s}{Source Dataframe: ISO 3166-1 alpha-3 country codes}
#'   \item{iso3_t}{Traget Dataframe: ISO 3166-1 alpha-3 country codes}
#'   \item{city_s}{Source Dataframe: City Name}
#'   \item{city_t}{Source Dataframe: City Name}
#'   \item{address_s}{Source Dataframe: Address Name}
#'   \item{address_t}{Traget Dataframe: Address Name}
#'   \item{match}{Indicator for matched names (always 1)}
#' }
"matches"
```

```{r function-legal_form_gleif, filename = "datasets"}
#' Dataset: Legal Forms from the GLEIF
#'
#'
#' @format A data frame with 3,322 rows and 3 variables:
#' \describe{
#'   \item{iso3}{ISO 3166-1 alpha-3 country codes}
#'   \item{legal_form_orig}{Original legal form}
#'   \item{legal_form_stand}{Standardized legal form}
#' }
"legal_form_gleif"
```

```{r function-legal_form_ecb, filename = "datasets"}
#' Dataset: Legal Forms from the ECB
#'
#'
#' @format A data frame with 2,399 rows and 3 variables:
#' \describe{
#'   \item{iso3}{ISO 3166-1 alpha-3 country codes}
#'   \item{legal_form_orig}{Original legal form}
#'   \item{legal_form_stand}{Standardized legal form}
#' }
"legal_form_ecb"
```

```{r function-legal_form_all, filename = "datasets"}
#' Dataset: Combined Legal Forms from the GLEIF and ECB
#'
#'
#' @format A data frame with 4,933 rows and 3 variables:
#' \describe{
#'   \item{iso3}{ISO 3166-1 alpha-3 country codes}
#'   \item{legal_form_orig}{Original legal form}
#'   \item{legal_form_stand}{Standardized legal form}
#' }
"legal_form_all"
```



# Functions

## standardize_str
```{r dev-standardize_str}
.str <- "International Business Corporation"
.op = c("space", "punct", "case", "utf8")
```



```{r function-standardize_str}
#' Title
#' 
#' Description
#' 
#' @param .str A string
#' @param .op Operations to perform
#'
#' @return A string
#' 
#' @export
standardize_str <- function(.str, .op = c("space", "punct", "case", "utf8")) {
  str_ <- .str
  
  if ("punct" %in% .op) {
    str_ <- trimws(stringi::stri_replace_all_regex(str_, "\\W", " "))
    str_ <- trimws(stringi::stri_replace_all_regex(str_, "[[:punct:]]", " "))
    
    if (!"space" %in% .op) {
      str_ <- trimws(stringi::stri_replace_all_regex(str_, "([[:blank:]]|[[:space:]])+", " "))
    }
  }
  
  if ("space" %in% .op) {
    str_ <- trimws(stringi::stri_replace_all_regex(str_, "([[:blank:]]|[[:space:]])+", " "))
  }
  
  if ("case" %in% .op) {
    str_ <- toupper(str_)
  }
  
  if ("utf8" %in% .op) {
    str_ <- stringi::stri_enc_toutf8(str_)
  }
  
  return(str_)
  
}
```
  
```{r example-standardize_str, eval=FALSE}
standardize_str(c("jkldsa   jkdhas   äää  §$ ## #'''"))
```
  
```{r tests-standardize_str}
test_that("standardize_str works", {
  expect_true(inherits(standardize_str, "function")) 
})
```
  

## standardize_data
    
```{r function-standardize_data}
#' Title
#' 
#' Description
#' 
#' @param .data A dataframe
#' @param .cols Columns to standardize
#' @param .op Operations to perform
#'
#' @return A dataframe
#' 
#' @export
standardize_data <- function(.data, .cols, .op = c("space", "punct", "case", "utf8")) {
    
  tab_ <- .data
  for (i in .cols) {
    tab_[[i]] <- standardize_str(tab_[[i]])
  }
  
  return(tab_)
  
}
```
  
```{r example-standardize_data, eval=FALSE}
standardize_data(source, c("name", "iso3", "city", "address"))
```
  
```{r tests-standardize_data}
test_that("standardize_data works", {
  expect_true(inherits(standardize_data, "function")) 
})
```
  
## extract_legal_form
```{r dev-extract_legal_form}
.data <- source
.col <- "name"
.legal_forms <- tibble(.rows = 0)
.workers = future::availableCores()
```



```{r function-extract_legal_form}
#' Title
#' 
#' Description
#' 
#' @param .data A dataframe
#' @param .col The column with firm names
#' @param .legal_forms A dataframe with legal forms
#' @param .workers NUmber of workers for parallelisation
#'
#' @return A dataframe
#' 
#' @importFrom rlang :=
#' 
#' @export
extract_legal_form <- function(.data, .col, .legal_forms = data.frame(), .workers = future::availableCores()) {
  tmp <- legal_form_orig <- legal_form_stand <- legal_form <- name <- NULL
  
  if (nrow(.legal_forms) == 0) {
    tab_lf_ <- get("legal_form_all")
  } else {
    tab_lf_ <- .legal_forms
  }

  tab_ <- standardize_data(.data, .col)
  lf_ <- unique(tab_lf_[["legal_form_orig"]])
  nm_ <- tab_[[.col]]

  f_ <- carrier::crate(function(.lf, .nm) which(endsWith(.nm, paste0(" ", .lf))))
  future::plan("multisession", workers = 6)
  lf_ext_ <- furrr::future_map(
    .x = purrr::set_names(lf_, lf_),
    .f = ~ f_(.x, nm_),
    .options = furrr::furrr_options(seed = TRUE)
  )
  future::plan("default")
  lf_ext_ <- lf_ext_ %>%
    purrr::compact() %>%
    tibble::enframe(name = "legal_form_orig", value = "tmp") %>%
    tidyr::unnest(tmp) %>%
    dplyr::arrange(dplyr::desc(nchar(legal_form_orig))) %>%
    dplyr::distinct(tmp, .keep_all = TRUE)

  tab_ %>%
    dplyr::mutate(tmp = dplyr::row_number()) %>%
    dplyr::left_join(lf_ext_, by = "tmp") %>%
    dplyr::left_join(tab_lf_, by = c("iso3", "legal_form_orig")) %>%
    dplyr::rename(legal_form = legal_form_stand) %>%
    dplyr::relocate(legal_form, .after = !!dplyr::sym(.col)) %>%
    dplyr::mutate(
      !!dplyr::sym(paste0(.col, "_adj")) := trimws(
        stringi::stri_replace_last_fixed(name, legal_form_orig, "")
        ),
      .after = !!dplyr::sym(.col)
    ) %>%
    dplyr::select(-legal_form_orig, -tmp)
  
  
}
```
  
```{r example-extract_legal_form, eval=FALSE}
extract_legal_form(source, "name")
```
  
```{r tests-extract_legal_form}
test_that("extract_legal_form works", {
  expect_true(inherits(extract_legal_form, "function")) 
})
```

## match_col

```{r dev-match_col}
.s <- source[1:100, ]
.t <- target[1:1000, ]
.col <- "name"
.method = "osa"
.max_match = 10
.min_sim = 0
```

```{r function-match_col}
#' Match a on a single column
#' 
#' Description
#' 
#' @param .s 
#' The Source Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .t 
#' The Traget Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .col 
#' The column name to match as a string
#' @param .max_match 
#' Maximum number of matches to return (Default = 10)
#' @param .min_sim 
#' Minimum Similarity as defined by the chosen method
#' @param .method 
#' One of "osa", "lv", "dl", "hamming", "lcs", "qgram", "cosine", "jaccard", "jw", "soundex"
#' See stringdist package
#'
#' @return A Dataframe
match_col <- function(.s, .t, .col, .max_match = 10, .min_sim = .8, .method = "osa") {
  V1 <- value <- id <- name <- id_t <- sim <- NULL
  
  
  method_ <- match.arg(
    arg = .method,
    choices = c(
      "osa", "lv", "dl", "hamming", "lcs", "qgram", "cosine",
      "jaccard", "jw", "soundex"
    )
  )
  tab_ <- stringdist::stringsimmatrix(
    a = .s[[.col]],
    b = .t[[.col]],
    method = method_
  ) %>%
    tibble::as_tibble() %>%
    dplyr::mutate(id = dplyr::row_number(), .before = V1) %>%
    tidyr::pivot_longer(!dplyr::matches("id")) %>%
    dplyr::filter(value >= .min_sim) %>%
    dplyr::group_by(id) %>%
    dplyr::slice_max(order_by = value, n = .max_match) %>%
    dplyr::ungroup() %>%
    dplyr::rename(id_s = id, id_t = name) %>%
    dplyr::mutate(id_t = as.integer(gsub("V", "", id_t, fixed = TRUE))) %>%
    suppressWarnings()
  tab_[["id_s"]] <- .s[["id"]][tab_[["id_s"]]]
  tab_[["id_t"]] <- .t[["id"]][tab_[["id_t"]]]
  colnames(tab_) <- c("id_s", "id_t", paste0("sim_", .col))
  return(tab_)
}
```
  
  
```{r tests-match_col}
test_that("match_col works", {
  expect_true(inherits(match_col, "function")) 
})
```  

## match_data
```{r dev-match_data}
.s <- source[1:100, ]
.t <- target[1:1000, ]
.cols <- c("name", "iso3", "city", "address")
.method = "osa"
.max_match = 10
.min_sim = 0
.chunk <- 20
.progress = TRUE
.must_match <- c("iso3")
```
    
```{r function-match_data}
#' Title
#' 
#' Description
#' 
#' @param .s 
#' The Source Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .t 
#' The Traget Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .cols 
#' The column names to match as character vector
#' @param .max_match 
#' Maximum number of matches to return (Default = 10)
#' @param .min_sim 
#' Minimum Similarity as defined by the chosen method
#' @param .method 
#' One of "osa", "lv", "dl", "hamming", "lcs", "qgram", "cosine", "jaccard", "jw", "soundex"
#' @param .must_match Columns that must be matched perfectly
#' @param .progress Should a progress bar be shown?
#' See stringdist package
#' @return A Dataframe
#' 
#' @export
match_data <- function(.s, .t, .cols, .must_match = NULL, .max_match = 10, 
                       .min_sim = .8, .method = "osa", .progress = TRUE) {
  
  sim <- NULL
  
  if (!is.null(.must_match)) {
    vs_ <- tidyr::unite(.s[, .must_match], "tmp", dplyr::everything())[["tmp"]]
    ls_ <- split(.s, vs_)
    
    vt_ <- tidyr::unite(.t[, .must_match], "tmp", dplyr::everything())[["tmp"]]
    lt_ <- split(.t, vt_)
    
    lt_ <- lt_[names(lt_) %in% names(ls_)]
    ls_ <- ls_[names(lt_)]
  } else {
    ls_ <- list(.s)
    lt_ <- list(.t)
  }

  if (.progress) pb <- progress::progress_bar$new(total = length(ls_))
  purrr::map2_dfr(
    .x = ls_,
    .y = lt_,
    .f = ~ {
      if (.progress) pb$tick()
      tab_ <- match_col(.x, .y, .cols[1], .max_match, .min_sim, .method)

      if (length(.cols) > 1) {
        s_ <- dplyr::left_join(tab_, .x, by = c("id_s" = "id"))
        t_ <- dplyr::left_join(tab_, .y, by = c("id_t" = "id"))

        for (i in 2:length(.cols)) {
          a <- stringdist::stringsim(s_[[.cols[i]]], t_[[.cols[i]]], .method)

          tab_[[paste0("sim_", .cols[i])]] <- stringdist::stringsim(s_[[.cols[i]]], t_[[.cols[i]]], .method)
        }
      }
      gc()
      return(tab_)
    }
  )
}
```
  
```{r example-match_data, eval=FALSE}
library(Rmatch)
match_data(source, target, c("name", "iso3", "city"), .min_sim = 0, .must_match = "iso3")
```

```{r tests-match_data}
test_that("match_data works", {
  expect_true(inherits(match_data, "function")) 
})
```

## uniqueness_vec
```{r dev-uniqueness_vec}
.vec <- source[["name"]][1:10]
```


```{r function-uniqueness_vec}
#' Uniquness/Rarity of a vector 
#' 
#' Description
#' 
#' @param .vec A character vector
#'
#' @return A numeric vector
#' 
#' @noRd
uniqueness_vec <- function(.vec) {
  l1_ <- stringi::stri_split_fixed(.vec, " ")
  v1_ <- unlist(l1_)
  v2_ <- as.integer(stats::ave(v1_, v1_, FUN = length))
  l2_ <- utils::relist(v2_, l1_)
  v3_ <- purrr::map_int(l2_, ~ sum(.x, na.rm = TRUE))
  
  1 - (v3_ / max(v3_))
}
```
  
```{r example-uniqueness_vec, eval=FALSE}
uniqueness_vec(source[["name"]][1:10])
```
  
```{r tests-uniqueness_vec}
test_that("uniqueness_vec works", {
  expect_true(inherits(uniqueness_vec, "function")) 
})
```
  
## uniqueness_data

```{r dev-uniqueness_data}
.data <- source
.cols <- c("name", "iso3", "city", "address")
.type <- "source"
```


```{r function-uniqueness_data}
#' Title
#' 
#' Description
#' 
#' @param .data A Dataframe
#' @param .cols Column as character vector
#' @param .type either source or target
#'
#' @return A dataframe
#' 
#' @export
uniqueness_data <- function(.data, .cols, .type = c("source", "target")) {
  id <- NULL
  type_ <- match.arg(.type, c("source", "target"))
  type_ <- substr(type_, 1, 1)
  tab_ <- .data

  for (i in seq_len(length(.cols))) {
    tab_[[paste0("uni_", type_, i)]] <- uniqueness_vec(tab_[[.cols[i]]])
  }
  
  tab_ <- dplyr::select(tab_, id, dplyr::starts_with("uni_"))
  
  if (.type == "source") {
    dplyr::rename(tab_, id_s = id)
  } else {
    dplyr::rename(tab_, id_t = id)
  }
  
}
```
  
```{r example-uniqueness_data, eval=FALSE}
uniqueness_data(source, c("name", "iso3", "city", "address"), "source")
```
  
```{r tests-uniqueness_data}
test_that("uniqueness_data works", {
  expect_true(inherits(uniqueness_data, "function")) 
})
```
  
  
## scores_data
```{r dev-scores_data}
.data <- tab_match
```

```{r function-scores_data}
#' Score Data
#' 
#' Description
#' 
#' @param .data A dataframe
#'
#' @return A dataframe
#' 
#' @export
scores_data <- function(.data) {
  id_s <- id_t <- NULL
  tab_ <- .data
  cols_ <- colnames(tab_)
  cols_ <- cols_[grepl("^sim_|^uni_", cols_)]
  
  tab_ %>%
    dplyr::select(id_s, id_t) %>%
    dplyr::mutate(
      score_mean = rowMeans(as.matrix(tab_[, cols_]), na.rm = TRUE)
    )
  
}
```
  
```{r tests-scores_data}
test_that("scores_data works", {
  expect_true(inherits(scores_data, "function")) 
})
```
   
   
## dedup_data
```{r dev-dedup_data}
.score <- tab_score
.source <- source
.target <- target
.col <- "score_mean"
```



```{r function-dedup_data}
#' Deduplicate Data
#' 
#' Description
#' 
#' @param .score Dataframe generated by scores_data()
#' @param .source 
#' The Source Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .target 
#' The Traget Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .col score column generated by scores_data()
#'
#' @return A dataframe
#' 
#' @export
dedup_data <- function(.score, .source, .target, .col) {
  id_s <- id_t <- name_s <- name_t <- NULL
  
  col_s_ <- colnames(.source)
  col_t_ <- colnames(.target)
  col_e_ <- col_s_[col_s_ %in% col_t_]
  col_e_ <- col_e_[!col_e_ == "id"]
  col_e_ <- unlist(purrr::map2(paste0(col_e_, "_s"), paste0(col_e_, "_t"), c))
  
  tab_ <- .score %>%
    dplyr::select(id_s, id_t, !!dplyr::sym(.col)) %>%
    dplyr::arrange(dplyr::desc(!!dplyr::sym(.col))) %>%
    dplyr::filter(!duplicated(id_t)) %>%
    dplyr::distinct(id_s, .keep_all = TRUE) %>%
    dplyr::full_join(.source, c("id_s" = "id"), FALSE, suffix = c("_s", "_t")) %>%
    dplyr::left_join(.target, c("id_t" = "id"), FALSE, suffix = c("_s", "_t")) %>%
    dplyr::rowwise() %>%
    dplyr::mutate(diff_name = list(diffmatchpatch::diff_make(name_s, name_t)))
  
  tab_ <- tab_[, c("id_s", "id_t", .col, col_e_)]
  return(tab_)
}
```
  
```{r example-dedup_data}
# dedup_data()
```
  
```{r tests-dedup_data}
test_that("dedup_data works", {
  expect_true(inherits(dedup_data, "function")) 
})
```
  
   


```{r development-inflate, eval=FALSE}
fusen::inflate(
  flat_file = "dev/flat_full.Rmd", 
  vignette_name = NA, overwrite = "no"
  )
```


# Inflate your package

You're one inflate from paper to box.
Build your package from this very Rmd using `fusen::inflate()`

- Verify your `"DESCRIPTION"` file has been updated
- Verify your function is in `"R/"` directory
- Verify your test is in `"tests/testthat/"` directory
- Verify this Rmd appears in `"vignettes/"` directory
