# Generated by fusen: do not edit by hand

#' Title
#' 
#' Description
#' 
#' @param .source
#' The Source Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .target
#' The Traget Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @return Messages
#' 
#' @export
#' @examples
#' check_data(table_source, table_target)
check_data <- function(.source, .target) {
  cols_s_  <- colnames(.source)
  cols_t_  <- colnames(.target)
  cols_e_  <- cols_s_[cols_s_ %in% cols_t_]
  cols_ns_ <- cols_s_[!cols_s_ %in% cols_t_]
  cols_nt_ <- cols_t_[!cols_t_ %in% cols_s_]

  p0 <- \(...) paste0(...)
  le <- \(...) length(...)
  p1 <- \(...) paste(..., collapse = ", ")
  sc <- \(.x, .a = NULL) scales::comma(.x, accuracy = .a)
  cl <- \(.c, .x) crayon::bold(ifelse(.c, crayon::green(.x), crayon::red(.x)))
  bd <- \(...) crayon::bold(...)
  ad <- \(.x) any(duplicated(.x))
  sl <- \(.x, .l) sprintf(p0("%-", .l, "s"), .x)
  
  un <- \(.tab, .cols) {
    tmp <- NULL
    cols_ <- .cols[.cols != "id"]
    char_ <- nchar(p1(cols_))
    chr <- c()
    tab0_ <- tibble::as_tibble(.tab) 

    for (i in seq_len(le(cols_))) {
      tab_ <- tab0_[, cols_[1:i]] %>%
        tidyr::unite("tmp", dplyr::everything()) %>%
        dplyr::filter(duplicated(tmp) | duplicated(tmp, fromLast = TRUE))
      
      chr[i] <- p0(
        sl(p1(cols_[1:i]), char_), 
        " - Duplictes: ", cl(nrow(tab_) == 0, sc(nrow(tab_)))
        )
    }
    return(chr)
  }
  
  na <- function(.source, .target, .cols) {
    s_ <- t_ <- c()
    for (i in .cols) {
      s_[i] <- sum(is.na(.source[[i]]))
      t_[i] <- sum(is.na(.target[[i]]))
    }
    l0_ <- max(nchar(names(s_))) + 2
    l1_ <- max(purrr::map_chr(s_, sc))
    purrr::pmap_chr(
      .l = list(names(s_), s_, t_),
      .f = ~ p0(
        sl(p0(..1, ": "), l0_), 
        "Source: ", cl(..2 == 0, sl(sc(..2), l1_)), " - ",
        "Target: ", cl(..3 == 0, sc(..3))
        )
      )
  }

  
  cat(bd("\nCheck ID Columns ----------------------------------------------\n"))
  cat(sep = "\n",
    p0("Source dataset contains 'id' column: ", cl("id" %in% cols_s_, "id" %in% cols_s_)),
    p0("Target dataset contains 'id' column: ", cl("id" %in% cols_t_, "id" %in% cols_s_))
  )
  
  cat(bd("\nCheck Overlapping Columns -------------------------------------\n"))
  cat(sep = "\n",
    p0(le(cols_e_), " column(s) in BOTH datasets: ", bd(p1(cols_e_))),
    p0(le(cols_ns_), " column(s) only in the Source dataset: ", bd(p1(cols_ns_))),
    p0(le(cols_nt_), " column(s) only in the Target dataset: ", bd(p1(cols_nt_)))
  )

  cat(bd("\nCheck IDs -----------------------------------------------------\n"))
  cat(sep = "\n",
    p0("Source Dataset has unique IDs: ", cl(!ad(.source[["id"]]), !ad(.source[["id"]]))),
    p0("Target Dataset has unique IDs: ", cl(!ad(.target[["id"]]), !ad(.target[["id"]])))
  )
  
  cat(bd("\nCheck Missing Values ------------------------------------------\n"))
  cat(na(.source, .target, cols_e_), sep = "\n")
  
  cat(bd("\nCheck Source Dataset Combination ------------------------------\n"))
  cat(un(.source, cols_e_), sep = "\n")
  
  cat(bd("\nCheck Target Dataset Combination ------------------------------\n"))
  cat(un(.target, cols_e_), sep = "\n")

  cat(bd("\nCheck Rows ----------------------------------------------------\n"))
  cat(sep = "\n",
    p0("Source Dataset contains ", bd(sc(nrow(.source)), "rows")),
    p0("Target Dataset contains ", bd(sc(nrow(.target)), "rows"))
  )

  cat(bd("\nEstimate Memory Allocation ------------------------------------\n"))
  cat(sep = "\n",
    p0("Similarity Matrix will contain ", bd(sc(nrow(.target) * nrow(.source))), " elements"),
    p0("Estimated memory allocation: ", bd(sc(nrow(.target) * nrow(.source) * 8 * 20 / 1e9, .01)), " GB"),
    p0("Consider setting the .chunk argument in match_data() to more than 1")
  )
}
