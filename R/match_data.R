# Generated by fusen: do not edit by hand

#' Title
#' 
#' Description
#' 
#' @param .source 
#' The Source Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .target 
#' The Traget Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .cols 
#' The column names to match as character vector
#' @param .max_match 
#' Maximum number of matches to return (Default = 10)
#' @param .min_sim 
#' Minimum Similarity as defined by the chosen method
#' @param .method 
#' One of "osa", "lv", "dl", "hamming", "lcs", "qgram", "cosine", "jaccard", "jw", "soundex"
#' @param .must_match Columns that must be matched perfectly
#' @param .progress Should a progress bar be shown?
#' See stringdist package
#' @param .chunk Chunk your data
#'
#' @return A dataframe
#' 
#' @export
#' @examples
#' match_data(
#'   .source = table_source[1:100, ],
#'   .target = table_target[1:999, ],
#'   .cols = c("name", "iso3", "city"),
#'   .min_sim = .2,
#'   .max_match = 10,
#'   .must_match = "iso3",
#'   .chunk = 5, 
#'   .method = "osa", 
#'   .progress = TRUE
#' )
match_data <- function(.source, .target, .cols, .must_match = NULL, .max_match = 10,
                            .min_sim = .8, .method = "osa", .chunk = 1, .progress = TRUE) {
  if (.chunk > 1) {
    ls_ <- split(
      x = .source,
      f = rep(1:.chunk, each = ceiling(nrow(.source) / .chunk))[1:nrow(.source)]
    )
  } else {
    ls_ <- list("1" = .source)
  }

  
  cols_ <- .cols[!.cols %in% .must_match]
  
  purrr::imap_dfr(
    .x = ls_,
    .f = ~ {
      if (.progress) cat("\rITERATION", .y)
      help_match_data(
        .source = .x,
        .target = .target,
        .cols = cols_,
        .must_match = .must_match,
        .max_match = .max_match,
        .min_sim = .min_sim,
        .method = .method,
        .progress = .progress
      )
    }
  )
}
