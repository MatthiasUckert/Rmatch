# Generated by fusen: do not edit by hand

#' Title
#' 
#' Description
#' 
#' @param .s 
#' The Source Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .t 
#' The Traget Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .cols 
#' The column names to match as character vector
#' @param .max_match 
#' Maximum number of matches to return (Default = 10)
#' @param .min_sim 
#' Minimum Similarity as defined by the chosen method
#' @param .method 
#' One of "osa", "lv", "dl", "hamming", "lcs", "qgram", "cosine", "jaccard", "jw", "soundex"
#' @param .must_match Columns that must be matched perfectly
#' @param .progress Should a progress bar be shown?
#' See stringdist package
#' @return A Dataframe
#' 
#' @export
#' @examples
#' library(Rmatch)
#' match_data(source, target, c("name", "iso3", "city"), .min_sim = 0, .must_match = "iso3")
match_data <- function(.s, .t, .cols, .must_match = NULL, .max_match = 10, 
                       .min_sim = .8, .method = "osa", .progress = TRUE) {
  
  sim <- NULL
  
  if (!is.null(.must_match)) {
    vs_ <- tidyr::unite(.s[, .must_match], "tmp", dplyr::everything())[["tmp"]]
    ls_ <- split(.s, vs_)
    
    vt_ <- tidyr::unite(.t[, .must_match], "tmp", dplyr::everything())[["tmp"]]
    lt_ <- split(.t, vt_)
    
    lt_ <- lt_[names(lt_) %in% names(ls_)]
    ls_ <- ls_[names(lt_)]
  } else {
    ls_ <- list(.s)
    lt_ <- list(.t)
  }

  if (.progress) pb <- progress::progress_bar$new(total = length(ls_))
  purrr::map2_dfr(
    .x = ls_,
    .y = lt_,
    .f = ~ {
      if (.progress) pb$tick()
      tab_ <- match_col(.x, .y, .cols[1], .max_match, .min_sim, .method)

      if (length(.cols) > 1) {
        s_ <- dplyr::left_join(tab_, .x, by = c("id_s" = "id"))
        t_ <- dplyr::left_join(tab_, .y, by = c("id_t" = "id"))

        for (i in 2:length(.cols)) {
          a <- stringdist::stringsim(s_[[.cols[i]]], t_[[.cols[i]]], .method)

          tab_[[paste0("sim_", .cols[i])]] <- stringdist::stringsim(s_[[.cols[i]]], t_[[.cols[i]]], .method)
        }
      }
      gc()
      return(tab_)
    }
  )
}
