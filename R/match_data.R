# Generated by fusen: do not edit by hand

#' Match Data
#' 
#' Description
#' 
#' @param .source 
#' The Source Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .target 
#' The Target Dataframe. 
#' Must contain a unique column id and the columns you want to match on
#' @param .cols 
#' The column names to match as character vector
#' @param .join
#' Columns to match on
#' @param .max_match 
#' Maximum number of matches to return (Default = 10)
#' @param .min_sim 
#' Minimum Similarity as defined by the chosen method
#' @param .method 
#' One of "osa", "lv", "dl", "hamming", "lcs", "qgram", "cosine", "jaccard", "jw", "soundex"
#' @param .must_match Columns that must be matched perfectly
#' @param .progress Should a progress bar be shown?
#' See stringdist package
#' @param .char_block 
#' Character Block Size
#' First element chunks the source data in ngram blocks
#' Second element allows for characters in target below/above block size
#' @param .workers Number of cores
#' @return A dataframe
#' 
#' @export
#' @examples
#' tab_source <- table_source[1:100, ]
#' tab_target <- table_target[1:999, ]
#' cols <- c("name", "iso3", "city", "address")
#' must <- "iso3"
#' match_data(
#'   .source = tab_source,
#'   .target = tab_target,
#'   .cols = cols,
#'   .must_match = must,
#' )
match_data <- function(.source, .target, .cols, .join = NULL, .must_match = NULL, .max_match = 10,
                       .min_sim = .2, .method = "osa", .char_block = c(Inf, Inf), .progress = TRUE,
                       .workers = future::availableCores()) {
  id <- n__ <- b__ <- NULL
  .source <- tibble::as_tibble(.source)
  .target <- tibble::as_tibble(.target)
  
  
  check_id(.source, .target)
  
  if (!is.null(.join)) {
    tab0_ <- join_data(.source, .target, .cols, .join)
    s_ <- dplyr::filter(.source, !id %in% tab0_$id_s)
    t_ <- dplyr::filter(.target, !id %in% tab0_$id_t)
  } else {
    tab0_ <- tibble::tibble(id_s = "", .rows = 0)
    s_ <- .source
    t_ <- .target
  }
  
  s_ <- s_ %>%
    dplyr::mutate(n__ = nchar(!!dplyr::sym(.cols[1]))) %>% 
    dplyr::arrange(n__) %>%
    dplyr::mutate(b__ = floor(n__ / .char_block[1])) %>%
    dplyr::group_by(b__) %>%
    dplyr::mutate(b__ = paste0(dplyr::first(n__), "-", dplyr::last(n__))) %>%
    dplyr::ungroup()
  ls_ <- split(dplyr::select(s_, -c(n__, b__)), s_$b__)
  t_ <- dplyr::mutate(t_, n__ = nchar(!!dplyr::sym(.cols[1])))
  
  filter_block <- function(.block, .tab, .size) {
    int_ <- as.integer(unlist(stringi::stri_split_fixed(.block, "-")))
    min_ <- int_[1] - .size
    max_ <- int_[2] + .size
    if (is.infinite(.size)) {
      return(.tab)
    } else {
      return(dplyr::filter(.tab, n__ %in% min_:max_))
    }
    
  }

  tab1_ <- purrr::imap_dfr(
    .x = ls_,
    .f = ~ {
      if (.progress) cat("\rCalculating Block:", .y, "     ")
      help_match_data(
        .source = .x,
        .target = filter_block(.y, t_, .char_block[2]),
        .cols = .cols,
        .must_match = .must_match,
        .max_match = .max_match,
        .min_sim = .min_sim,
        .method = .method,
        .progress = .progress, 
        .workers = .workers
      )
    }
  )

  out_ <- dplyr::bind_rows(tab0_, tab1_)
  out_ <- out_[, c("id_s", "id_t", paste0("sim_", .cols))]
  
}
